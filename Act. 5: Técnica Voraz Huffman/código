import tkinter as tk
from tkinter import ttk, messagebox
from collections import Counter
import os


class NodoHuffman:
    def __init__(self, caracter, frecuencia):
        self.caracter = caracter
        self.frecuencia = frecuencia
        self.izquierdo = None
        self.derecho = None

    def __lt__(self, otro):
        return self.frecuencia < otro.frecuencia


class CompresorHuffman:
    def __init__(self):
        self.frecuencias = {}
        self.codigos = {}
        self.arbol_huffman = None
        self.texto_original = ""

    def leer_archivo(self, ruta_archivo):
        with open(ruta_archivo, 'r', encoding='utf-8') as f:
            self.texto_original = f.read()

    def calcular_frecuencias(self):
        self.frecuencias = Counter(self.texto_original)
        return self.frecuencias

    def construir_arbol(self):
        nodos = [NodoHuffman(caracter, frecuencia)
                 for caracter, frecuencia in self.frecuencias.items()]

        while len(nodos) > 1:
            nodos.sort(key=lambda x: x.frecuencia)
            izquierdo = nodos.pop(0)
            derecho = nodos.pop(0)
            nuevo_nodo = NodoHuffman(None, izquierdo.frecuencia + derecho.frecuencia)
            nuevo_nodo.izquierdo = izquierdo
            nuevo_nodo.derecho = derecho
            nodos.append(nuevo_nodo)

        self.arbol_huffman = nodos[0]
        return self.arbol_huffman

    def generar_codigos(self, nodo=None, codigo_actual=""):
        if nodo is None:
            self.codigos = {}
            nodo = self.arbol_huffman

        if nodo.caracter is not None:
            self.codigos[nodo.caracter] = codigo_actual
            return

        self.generar_codigos(nodo.izquierdo, codigo_actual + "0")
        self.generar_codigos(nodo.derecho, codigo_actual + "1")

        return self.codigos

    def codificar_texto(self):
        return ''.join(self.codigos[caracter] for caracter in self.texto_original)

    def bin_string_a_bytes(self, bin_string):
        padding = 8 - len(bin_string) % 8
        if padding != 8:
            bin_string += '0' * padding

        bytes_data = bytearray()
        for i in range(0, len(bin_string), 8):
            byte = bin_string[i:i + 8]
            bytes_data.append(int(byte, 2))

        return bytes_data


class HuffmanGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Compresor Huffman")
        self.root.geometry("800x600")

        self.compresor = CompresorHuffman()

        # ARCHIVO FIJO - MODIFICA ESTA RUTA
        self.archivo_fijo = r"C:\Users\cinth\Downloads\prueba.txt"

        self.crear_interfaz()

        # Cargar archivo automáticamente
        try:
            self.compresor.leer_archivo(self.archivo_fijo)
            self.actualizar_info(
                f"Archivo cargado: {self.archivo_fijo}\nCaracteres: {len(self.compresor.texto_original)}")
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo cargar el archivo:\n{str(e)}")

    def crear_interfaz(self):
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)

        # Botones
        botones_frame = ttk.Frame(main_frame)
        botones_frame.grid(row=1, column=0, columnspan=2, pady=10)

        ttk.Button(botones_frame, text="1. Calcular Frecuencias", command=self.calcular_frecuencias).pack(side=tk.LEFT,
                                                                                                          padx=2)
        ttk.Button(botones_frame, text="2. Construir Árbol", command=self.construir_arbol).pack(side=tk.LEFT, padx=2)
        ttk.Button(botones_frame, text="3. Generar Códigos", command=self.generar_codigos).pack(side=tk.LEFT, padx=2)
        ttk.Button(botones_frame, text="4. Codificar", command=self.codificar_archivo).pack(side=tk.LEFT, padx=2)

        # Tabla
        tabla_frame = ttk.LabelFrame(main_frame, text="Caracteres y Códigos", padding="5")
        tabla_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=10)

        self.tree = ttk.Treeview(tabla_frame, columns=('Caracter', 'Frecuencia', 'Codigo'), show='headings', height=15)
        self.tree.heading('Caracter', text='Carácter')
        self.tree.heading('Frecuencia', text='Frecuencia')
        self.tree.heading('Codigo', text='Código')

        scrollbar = ttk.Scrollbar(tabla_frame, orient=tk.VERTICAL, command=self.tree.yview)
        self.tree.configure(yscrollcommand=scrollbar.set)

        self.tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))

        tabla_frame.columnconfigure(0, weight=1)
        tabla_frame.rowconfigure(0, weight=1)

        # Info
        self.info_label = ttk.Label(main_frame, text="", wraplength=700)
        self.info_label.grid(row=3, column=0, columnspan=2, sticky=tk.W, pady=10)

        main_frame.rowconfigure(2, weight=1)

    def calcular_frecuencias(self):
        frecuencias = self.compresor.calcular_frecuencias()

        for item in self.tree.get_children():
            self.tree.delete(item)

        for caracter, freq in sorted(frecuencias.items(), key=lambda x: x[1], reverse=True):
            char_display = "\\n" if caracter == '\n' else "\\t" if caracter == '\t' else "espacio" if caracter == ' ' else caracter
            self.tree.insert('', tk.END, values=(char_display, freq, ""))

        self.actualizar_info(f"Frecuencias calculadas: {len(frecuencias)} caracteres únicos")

    def construir_arbol(self):
        self.compresor.construir_arbol()
        self.actualizar_info("Árbol de Huffman construido")

    def generar_codigos(self):
        codigos = self.compresor.generar_codigos()

        for item in self.tree.get_children():
            valores = self.tree.item(item)['values']
            caracter_display = valores[0]

            caracter = {'\\n': '\n', '\\t': '\t', 'espacio': ' '}.get(caracter_display, caracter_display)

            if caracter in codigos:
                self.tree.set(item, 'Codigo', codigos[caracter])

        self.actualizar_info("Códigos generados")

    def codificar_archivo(self):
        texto_codificado = self.compresor.codificar_texto()
        bytes_codificados = self.compresor.bin_string_a_bytes(texto_codificado)

        nombre_base = os.path.splitext(os.path.basename(self.archivo_fijo))[0]
        archivo_salida = f"{nombre_base}_comprimido.bin"

        with open(archivo_salida, 'wb') as f:
            f.write(bytes_codificados)

        tam_original = len(self.compresor.texto_original.encode('utf-8'))
        tam_comprimido = len(bytes_codificados)
        ratio = (1 - tam_comprimido / tam_original) * 100

        self.actualizar_info(
            f"COMPRESIÓN TERMINADA\nArchivo: {archivo_salida}\nOriginal: {tam_original} bytes\nComprimido: {tam_comprimido} bytes\nCompresión: {ratio:.1f}%")

    def actualizar_info(self, mensaje):
        self.info_label.config(text=mensaje)


if __name__ == "__main__":
    root = tk.Tk()
    app = HuffmanGUI(root)
    root.mainloop()
